//----------------------- 1 --------------------//Name That Integer
// Напишите метод detect_int, который возвращает первое положительное целое число,
// для которого произвольное число лямбда - выражений возвращает значение true.
// Если аргументы не переданы, то detect_intдолжен вернуть 1.

// function detectInt(...fns) {
//     let x = 1;

//     while (true) {
//         if (fns.every(fn => fn(x))) {
//             return x;
//         }
//         x += 1;
//     }
// }

// const lam1 = (x) => x ** 0.5 % 1 == 0;
// const lam2 = (x) => x > 9;
// console.log(detectInt(lam1, lam2));

// const fn2 = (x) => x % 6 === 0;
// const fn3 = (x) => x.toString().length >= 2;

// console.log(detectInt(fn1, fn2, fn3)); // 12
// console.log(detectInt(fn1, fn2)); // 6
//=======================================================================================================

//----------------------- 2 --------------------//zipWith
// zipWithберет функцию и два массива и объединяет массивы вместе, применяя функцию к каждой паре значений.
// Значением функции является один новый массив.Если массивы имеют неравную длину, вывод будет такой же
// длины, как и более короткий.

// function repeat(a, i) {
//     return a.repeat(i + 1);
// }
// console.log(repeat("a", 0));

// function zipWith(fn, a0, a1) {
//     const length = Math.min(a0.length, a1.length);

//     const arr = [];
//     for (let i = 0; i < length; i += 1) {
//         arr.push(fn(a0[i], a1[i]));
//     }
//     return arr;
// }
// console.log(zipWith(Math.max, [1, 4, 7, 1, 4, 7], [4, 7, 1, 4, 7, 1]));
//console.log(zipWith(repeat, ["a", "b", "c", "d", "e", "f"], []));
//==============================================================================================

//----------------------- 3 --------------------//Functional Addition
//Создайте функцию add(n), которая возвращает функцию, которая всегда добавляет n к любому числу.

// const add = (n) => {
//     return (a) => {
//         return a + n;
//     };
// };

// function add(n) {
//     return (a) => {
//         return a + n;
//     };
// }
//console.log(add(3)(2));
//==========================================================================================================

//----------------------- 4 --------------------//Currying functions: multiply all elements in an array
// создать функцию multiplyAll которая принимает в качестве аргумента массив целых чисел.
//  Эта функция должна возвращать другую функцию, которая принимает одно целое число в качестве аргумента и
//возвращает новый массив.
// Возвращаемый массив должен состоять из каждого элемента из первого массива, умноженного на целое число.

// function multiplyAll(a) {
//     return (b) => {
//         return a.map((el) => el * b);
//     };
// }
// console.log(multiplyAll([1, 2, 3])(2));
//==============================================================================================================

//----------------------- 5 --------------------// Chain me
//Напишите универсальную цепочку функций, которая принимает начальное значение и массив функций для его выполнения
// function chain(input, fs) {
//     let a = input;
//     for (const fn of fs) {
//         a = fn(a);
//     }
//     return a;
// }

// const double = (x) => x * 2;
// const sq = (x) => x * x;
// const divide = (x) => x / 2;
// console.log(chain(3, [double, sq, divide])); // 3   →   6 → 36 → 18
//==========================================================================

//----------------------- 6 --------------------//7 kyu The Span Function
// Он принимает последовательность и функцию - предикат и возвращает две
// последовательности.Первая последовательность содержит все элементы
// последовательности аргументов до элемента, вызвавшего первую ошибку
// предиката.Вторая возвращенная последовательность содержит остальную
// часть исходной последовательности.Исходная последовательность не изменена.

// function isEven(x) {
//     return Math.abs(x) % 2 === 0;
// }
// function isOdd(x) {
//     return Math.abs(x) % 2 !== 0;
// }
// function span(arr, predicate) {
//     const i = arr.findIndex((el) => !predicate(el));
//     if (i === -1) {
//         return [arr, []];
//     }
//     return [arr.slice(0, i), arr.slice(i)];
// }
// console.log(span([2, 4, 6, 12, 8, 10], isEven)); // [[2, 4, 6, 12, 8, 10], []]
// console.log(span([2, 4, 6, 5, 8, 10], isEven)); // [[2, 4, 6], [5, 8, 10]]
//=====================================================================================

//----------------------- 7 --------------------//The dropWhile Function
// есть последовательность значений и некоторый предикат для этих значений.
//  Вы хотите удалить самый длинный префикс элементов, чтобы предикат был
//   истинным для каждого элемента.Мы назовем это функцией dropWhile

// function isEven(num) {
//     return num % 2 === 0;
// }

// function dropWhile(arr, pred) {
//     if (idx===-1 ) {return [] }
//     const idx = arr.findIndex(el => !pred(el));
//      return arr.slice( idx);
// } 
//  console.log(dropWhile([ 4, 2, 3, 5, 4, 5, 6, 7], isEven)); // 


//  var seq = [2,4,6,8,1,2,5,4,3,2];
// dropWhile(seq, isEven) // -> [1,2,5,4,3,2]
 

// var seq = [1,2,4,6,8,1,2,5,4,3,2];
// dropWhile(seq, isEven) // -> [1, 2,4,6,8,1,2,5,4,3,2]


//----------------------- 8 --------------------//6 kyu Function composition

// const addOne = (a) => a + 1;
// const multTwo = (b) => b * 2;

// function compose(...fns) {
//     return (num) => {
//         return fns.reverse().reduce((akk, fn) => fn(akk), num);
//     };
// }
// console.log(compose(multTwo, addOne)(5));
//=======================================================================

//----------------------- 9 --------------------//7 kyu Sequence generator
// Реализовать функцию sequence, которая возвращает n массив нового размера, заполненный в соответствии с pattern.
// pattern может быть:
// a, function который принимает два: (element, index), один: (element)или любые аргументы(аналогично mapфункции),
//     затем заполняется запуском этой функции, другими словами: функция описывает последовательность,
// число, строка или любой другой объект, затем заполняется копированием этого объекта n- раз.

// function sequence(n, pattern) {
//     return typeof pattern !== "function"
//         ? Array(n).fill(pattern)
//         : Array(n).fill().map((_, i) => pattern(n, i));

// const arr = [];
// if (typeof pattern !== "function") {
//     for (let i = 0; i < n; i += 1) {
//         arr.push(pattern);
//     }
// } else {
//     for (let i = 0; i < n; i += 1) {
//         arr.push(pattern(n, i));
//     }
// }
// return arr;
//}
// console.log(sequence(5, 4));
//=========================================================

//----------------------- 10 --------------------//5 kyu Lazy Repeater
// Функция makeLooper() принимает строку(ненулевой длины)
// в качестве аргумента. Она возвращает функцию. Функция, которую онa возвращает,
// будет возвращать последовательные символы строки при последовательных вызовах.
// Он начнется с начала строки, как только она достигнет конца.

// function makeLooper(str) {
//     let i = 0;
//     return function () {
//         const res = str[i];
//         i++;
//         if (i === str.length) {
//             i = 0;
//         }
//         return res;
//     };
// }
// const looper = makeLooper("abc");
// console.log(looper());
// console.log(looper());
// console.log(looper());
// console.log(looper());
// console.log(looper());
// console.log(looper());
//====================================================================================

//----------------------- 11 --------------------//6 kyu Reusable memoisation
// Реализуйте повторно используемую функцию запоминания
//     , которая, учитывая функцию одного аргумента, возвращает запомненную функцию
// одного аргумента.Функции с более чем одним аргументом можно запоминать, каррируя
// функцию и запоминая ее для каждого аргумента, по одному за раз.Это проще для
// повторного использования, чем наличие другого компонента запоминания для каждого
//  количества аргументов.
// function memo(fn) {
//     return fn;
// }

// декораторы
// memo            
// once
// i-spy
// multiFilter
// Combinator Flip

// Stringing me along
// a-chain-adding-function

// ES5 Generators


